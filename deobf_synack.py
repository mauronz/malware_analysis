# Quick and dirty IDAPython script to decode the function calls/memory references of the SynACK ransomware
# by mauronz ( @FraMauronz )

from idc import *
from idautils import *

# get only immediates and memory references
def get_constant_op(head, num):
	op_type = GetOpType(head, num)
	if op_type == o_imm or op_type == o_mem:
		return GetOperandValue(head, num)
	return None


for head in Heads(MinEA(), MaxEA()):
	mnem = GetMnem(head)
	# first qword is loaded with a lea or read from memory with a mov
	if mnem == "lea" or mnem == "mov":
		reg = GetOpnd(head, 0)
		if GetOpType(head, 0) == o_reg and reg != "rsp":
			op2 = get_constant_op(head, 1)
			if op2:
				if mnem == "mov":
					op2 = Qword(op2)
				next = head
				# look for the second qword in the next 5 instructions
				for i in range(5):
					next = NextHead(next)
					mnem = GetMnem(next)
					# the operation between the two can be either an add or a sub
					if (mnem == "add" or mnem == "sub") and GetOpnd(next, 0) == reg:
						op2_next = get_constant_op(next, 1)
						if op2_next:
							if mnem == "add":
								result = (op2 + op2_next) & 0xffffffffffffffff
							else:
								result = (op2 - op2_next) & 0xffffffffffffffff
							MakeComm(next, "0x%x" % result)
							next2 = next
							# search for a call to the computed address in the next 5 instructions
							for j in range(5):
								next2 = NextHead(next2)
								if GetMnem(next2) == "call" and GetOpnd(next2, 0) == reg:
									# add an xref
									AddCodeXref(next2, result, fl_CF | XREF_USER)
									# tell IDA that a function starts from the called address
									MakeFunction(result)
							break
